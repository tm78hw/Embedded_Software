#include <B31DGMonitor.h>
#include <Arduino.h>

//Define Pin Names
#define TASK_1_DP 5
#define TASK_2_DP 6
#define TASK_3_DP 7
#define TASK_4_DP 1
#define TASK_4_LED 0
#define TASK_6_BUTTON 2
#define TASK_7_LED 3

//Initiate variables to count number of runs and Violations for each task
int task1Runs, task2Runs, task3Runs, task4Runs, task5Runs, task6Runs, task7Runs;
int task1Violations, task2Violations, task3Violations, task4Violations,
    task5Violations, task6Violations, task7Violations;

// Declare a mutex Semaphore Handle which we will use to manage the Serial Port.
// It will be used to ensure only only one Task is accessing this resource at any time.
SemaphoreHandle_t xSerialSemaphore;

// Declare the event queue handle
QueueHandle_t queueLED;

// Define the struct for tasks 2 and 3
typedef struct {
    int task2;
    int task3;
} frequencyGlobalStructure;

// Define a global variable of type frequencyGlobalStructure
frequencyGlobalStructure freqStruct;

// define 5 Tasks
void Task1( void *pvParameters );
void Task2( void *pvParameters );
void Task3( void *pvParameters );
void Task4( void *pvParameters );
void Task5( void *pvParameters );

void setup(void) {
  pinMode(TASK_1_DP, OUTPUT);     //Pin modes
  pinMode(TASK_2_DP, INPUT);
  pinMode(TASK_3_DP, INPUT);
  pinMode(TASK_4_DP, INPUT);
  pinMode(TASK_4_LED, OUTPUT);
  pinMode(TASK_6_BUTTON, INPUT_PULLUP);
  pinMode(TASK_7_LED, OUTPUT);
  Serial.begin(9600);             //Begin serial monitor

  // Semaphores are useful to stop a Task proceeding, where it should be paused to wait,
  // because it is sharing a resource, such as the Serial port.
  // Semaphores should only be used whilst the scheduler is running, but we can set it up here.
  if ( xSerialSemaphore == NULL )  // Check to confirm that the Serial Semaphore has not already been created.
  {
    xSerialSemaphore = xSemaphoreCreateMutex();  // Create a mutex semaphore we will use to manage the Serial Port
    
  if ( ( xSerialSemaphore ) != NULL )
    xSemaphoreGive( ( xSerialSemaphore ) );  // Make the Serial Port available for use, by "Giving" the Semaphore.
  }


  /* Now set up the five Tasks to run independently.
  xTaskCreate(
    Task1
    ,  "Task1"  // The name of the task
    ,  100  // This stack size can be checked & adjusted by reading the Stack Highwater
    ,  NULL
    ,  1  // Priority, with 1 being the highest, and 8 being the lowest.
    ,  NULL );
  */

  xTaskCreate(Task1,  "Task1",  2500  ,  NULL,  1  ,  NULL );
  xTaskCreate(Task2,  "Task2",  2500  ,  NULL,  3  ,  NULL );
  xTaskCreate(Task3,  "Task3",  2500  ,  NULL,  2  ,  NULL );
  xTaskCreate(Task4,  "Task4",  2500  ,  NULL,  4  ,  NULL );
  xTaskCreate(Task5,  "Task5",  2500  ,  NULL,  5  ,  NULL );
  xTaskCreate(Task6,  "Task6",  2500  ,  NULL,  6  ,  NULL );
  xTaskCreate(Task7,  "Task7",  2500  ,  NULL,  7  ,  NULL );
  xTaskCreate(Task8,  "Task8",  2500  ,  NULL,  8  ,  NULL );

  // Now the Task scheduler, which takes over control of scheduling individual Tasks, is automatically started.
  
}

//Loop to run function
void loop(void)
{
    //Empty as tasks are run seperately
}

//Define Tasks 1 - 5
void Task1(void *pvParameters) {                     //takes 286us
  TickType_t xCurrentExecutionTime;
  const TickType_t xFrequency = pdMS_TO_TICKS( 4 ); // Task period (in milliseconds)
  
  // Initialize xLastWakeTime to the current tick count
  xCurrentExecutionTime = xTaskGetTickCount();
  
  for (;;) // A Task shall never return or exit.
  {
    // See if we can obtain or "Take" the Serial Semaphore.
    // If the semaphore is not available, wait 200 ticks of the Scheduler to see if it becomes free.
    if ( xSemaphoreTake( xSerialSemaphore, ( TickType_t ) 200 ) == pdTRUE )
    {
      // Calculate total number runs for task 1
      task1Runs = task1Runs+1;   //Serial print
      
      //////// Calculate total number of violations ////////
      int currentFrame, lastFrame;
      if(currentFrame == NULL){
        currentFrame = xCurrentExecutionTime; //initialize first frame at the time the task was first run
      }
      currentFrame = currentFrame + xFrequency; //increment current frame by exactly 100ms

      if (xCurrentExecutionTime > currentFrame || xCurrentExecutionTime < lastFrame) {    // Check if the task to test has run every 100ms
        task1Violations = task1Violations + 1;     // Task has not run every 100ms
        } 

      lastFrame = currentFrame; //Save current frame as the previous frame for the next run
    
      //////// Run Task 2 ////////
      const int T1H = 200;    //Time 1 High in us
      const int T1L = 50;     //Time 1 Low in us
      const int T2H = 30;     //Time 2 High in us
      delayMicroseconds(30);
      digitalWrite(TASK_1_DP, HIGH);   //TASK_1_DP is held high for duration T1H
      delayMicroseconds(T1H);
      digitalWrite(TASK_1_DP, LOW);    //Then Low for duration T1L
      delayMicroseconds(T1L);
      digitalWrite(TASK_1_DP, HIGH);   //Then high for duration T2H
      delayMicroseconds(T2H);
      digitalWrite(TASK_1_DP, LOW);

      xSemaphoreGive( xSerialSemaphore ); // Now free or "Give" the Serial Port for others.
      
      //uint32_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
      //printf("Task 1 stack high water mark: %u\n", uxHighWaterMark);
    }

    // Wait until the end of the task period
    vTaskDelayUntil( &xCurrentExecutionTime, xFrequency );
  }
}

void Task2(void *pvParameters) {                    //takes 1000-3000us
  TickType_t xCurrentExecutionTime;
  const TickType_t xFrequency = pdMS_TO_TICKS( 20 ); // Task period (in milliseconds)

  // Initialize xLastWakeTime to the current tick count
  xCurrentExecutionTime = xTaskGetTickCount();
  
  for (;;)
  {
    // See if we can obtain or "Take" the Serial Semaphore.
    // If the semaphore is not available, wait 200 ticks of the Scheduler to see if it becomes free.
    if ( xSemaphoreTake( xSerialSemaphore, ( TickType_t ) 200 ) == pdTRUE )
    {
      // Calculate total number runs for task 2
      task2Runs = task2Runs+1;   //Serial print

      //////// Calculate total number of violations ////////
      int currentFrame, lastFrame;
      if(currentFrame == NULL){
        currentFrame = xCurrentExecutionTime; //initialize first frame at the time the task was first run
      }
      currentFrame = currentFrame + xFrequency; //increment current frame by exactly 100ms
      
      if (xCurrentExecutionTime > currentFrame || xCurrentExecutionTime < lastFrame) {    // Check if the task to test has run every 100ms
        task2Violations = task2Violations + 1;     // Task has not run every 100ms
        } 

      lastFrame = currentFrame; //Save current frame as the previous frame for the next run
      
      //////// Run Task 2 ////////
      int Task_2_TH;  //Initialize variables
      Task_2_TH = pulseIn(TASK_2_DP, HIGH, 4000);   //Measure time of high pulse
      
        if(Task_2_TH > 0){
          freqStruct.task2 = 1000000/(Task_2_TH*2);    //Compute frequnecy
        }
        else{
          freqStruct.task2 = 333;  
        }

      xSemaphoreGive( xSerialSemaphore ); // Now free or "Give" the Serial Port for others.

      //uint32_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
      //printf("Task 2 stack high water mark: %u bytes\n", uxHighWaterMark);
    }

    // Wait until the end of the task period
    vTaskDelayUntil( &xCurrentExecutionTime, xFrequency );
  }
}

void Task3(void *pvParameters) {                    //takes 1000-2000us
  TickType_t xCurrentExecutionTime;
  const TickType_t xFrequency = pdMS_TO_TICKS( 8 ); // Task period (in milliseconds)

  // Initialize xLastWakeTime to the current tick count
  xCurrentExecutionTime = xTaskGetTickCount();
  
  for (;;)
  {

    // See if we can obtain or "Take" the Serial Semaphore.
    // If the semaphore is not available, wait 200 ticks of the Scheduler to see if it becomes free.
    if ( xSemaphoreTake( xSerialSemaphore, ( TickType_t ) 200 ) == pdTRUE )
    {
      // Calculate total number runs for task 3
      int task3Counter;
      task3Runs = task3Runs+1;   //Serial print

      //////// Calculate total number of violations ////////
      int currentFrame, lastFrame;
      if(currentFrame == NULL){
        currentFrame = xCurrentExecutionTime; //initialize first frame at the time the task was first run
      }
      currentFrame = currentFrame + xFrequency; //increment current frame by exactly 100ms

      if (xCurrentExecutionTime > currentFrame || xCurrentExecutionTime < lastFrame) {    // Check if the task to test has run every 100ms
        task3Violations = task3Violations + 1;     // Task has not run every 100ms
      } 

      lastFrame = currentFrame; //Save current frame as the previous frame for the next run

      //////// Run Task 3 ////////
      int Task_3_TH;  //Initialize variables
      Task_3_TH = pulseIn(TASK_3_DP, HIGH, 3000);   //Measure time of high pulse
      if(Task_3_TH > 0){
         freqStruct.task3 = 1000000/(Task_3_TH*2);    //Compute frequnecy
      }
      else{
        freqStruct.task3 = 500;  
      }
      
      xSemaphoreGive( xSerialSemaphore ); // Now free or "Give" the Serial Port for others.
      //uint32_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
      //printf("Task 3 stack high water mark: %u bytes\n", uxHighWaterMark);
      
    }

    // Wait until the end of the task period
    vTaskDelayUntil( &xCurrentExecutionTime, xFrequency );
  }

}

void Task4(void *pvParameters) {                     //Takes 228us
  
    TickType_t xCurrentExecutionTime;
    const TickType_t xFrequency = pdMS_TO_TICKS( 20 ); // Task period (in milliseconds)

    // Initialize xLastWakeTime to the current tick count
    xCurrentExecutionTime = xTaskGetTickCount();
  
  for (;;)
  {

    // See if we can obtain or "Take" the Serial Semaphore.
    // If the semaphore is not available, wait 200 ticks of the Scheduler to see if it becomes free.
    if ( xSemaphoreTake( xSerialSemaphore, ( TickType_t ) 200 ) == pdTRUE )
    {
      // Calculate total number runs for task 4
      int task4Counter;
      task4Runs = task4Runs+1;   //Serial print

      
      //////// Calculate total number of violations ////////
      int currentFrame, lastFrame;
      if(currentFrame == NULL){
        currentFrame = xCurrentExecutionTime; //initialize first frame at the time the task was first run
      }
      currentFrame = currentFrame + xFrequency; //increment current frame by exactly 100ms

      if (xCurrentExecutionTime > currentFrame || xCurrentExecutionTime < lastFrame) {    // Check if the task to test has run every 100ms
        task4Violations = task4Violations + 1;     // Task has not run every 100ms
      } 

      lastFrame = currentFrame; //Save current frame as the previous frame for the next run

      //////// Run Task 4 ////////
      int Task_4_R1, Task_4_R2, Task_4_R3, Task_4_R4;
      float Task_4_Avg;
      
      if(task4Runs%4 == 0){
      Task_4_R1 = analogRead(TASK_4_DP);  //Measure four seperate analogue readings
      }
      
      if(task4Runs%4 == 1){
      Task_4_R2 = analogRead(TASK_4_DP);  //Store each one in a seperate register
      }
      
      if(task4Runs%4 == 2){
      Task_4_R3 = analogRead(TASK_4_DP);  //Measure four seperate analogue readings
      }

      if(task4Runs%4 == 3){
      Task_4_R4 = analogRead(TASK_4_DP);  //Measure four seperate analogue readings
      }

      //Then caclulate average of the 4 values and convert to voltage value
      Task_4_Avg = (Task_4_R1 + Task_4_R1 + Task_4_R1 + Task_4_R1)/(4*4095/3.3);
    
      if (Task_4_Avg >= 1.65){      //light LED when the voltage is above 1.65V
        digitalWrite(TASK_4_LED, HIGH);
      }
      else{                         //Turn off LED when voltage is below 1.65V
        digitalWrite(TASK_4_LED, LOW);
      }

      xSemaphoreGive( xSerialSemaphore ); // Now free or "Give" the Serial Port for others.
      //uint32_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
      //printf("Task 4 stack high water mark: %u bytes\n", uxHighWaterMark);
     
    }

    // Wait until the end of the task period
    vTaskDelayUntil( &xCurrentExecutionTime, xFrequency );
  }
}

void Task5(void *pvParameters) {                    //Takes 122us
  
    TickType_t xCurrentExecutionTime;
    const TickType_t xFrequency = pdMS_TO_TICKS( 100 ); // Task period (in milliseconds)

    // Initialize xLastWakeTime to the current tick count
    xCurrentExecutionTime = xTaskGetTickCount();
  
  for (;;)
  {

    // See if we can obtain or "Take" the Serial Semaphore.
    // If the semaphore is not available, wait 200 ticks of the Scheduler to see if it becomes free.
    if ( xSemaphoreTake( xSerialSemaphore, ( TickType_t ) 200 ) == pdTRUE )
    {

      // Calculate total number 
      int task5Counter;
      task5Runs = task5Runs+1;   //Serial print

      
      //////// Calculate total number of violations ////////
      int currentFrame, lastFrame;
      if(currentFrame == NULL){
        currentFrame = xCurrentExecutionTime; //initialize first frame at the time the task was first run
      }
      currentFrame = currentFrame + xFrequency; //increment current frame by exactly 100ms

      if (xCurrentExecutionTime > currentFrame || xCurrentExecutionTime < lastFrame) {    // Check if the task to test has run every 100ms
        task5Violations = task5Violations + 1;     // Task has not run every 100ms
      } 

      lastFrame = currentFrame; //Save current frame as the previous frame for the next run
 
      //Perform Task 5
      int Task_2_Freq_Int, Task_3_Freq_Int;
      Task_2_Freq_Int = map(freqStruct.task2,333,1000, 0, 99);   //Limit integers to only
      Task_3_Freq_Int = map(freqStruct.task3,500,1000, 0, 99);   //between 0 and 99.99
      Task_2_Freq_Int = constrain(Task_2_Freq_Int,0,99);   //Limit integers to only
      Task_3_Freq_Int = constrain(Task_3_Freq_Int,0,99);   //between 0 and 99.99
      
      Serial.printf("%d,", Task_2_Freq_Int );   //Serial print
      Serial.printf("%d\n", Task_3_Freq_Int ); //integers
    
      xSemaphoreGive( xSerialSemaphore ); // Now free or "Give" the Serial Port for others.
      //uint32_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
      //printf("Task 5 stack high water mark: %u bytes\n", uxHighWaterMark);
        
      }

    // Wait until the end of the task period
    vTaskDelayUntil( &xCurrentExecutionTime, xFrequency );
  }
}

void Task6(void *pvParameters) {                    //Takes 122us
  
    TickType_t xCurrentExecutionTime;
    const TickType_t xFrequency = pdMS_TO_TICKS( 100 ); // Task period (in milliseconds)

    // Initialize xLastWakeTime to the current tick count
    xCurrentExecutionTime = xTaskGetTickCount();
   
  for (;;)
  {

    // See if we can obtain or "Take" the Serial Semaphore.
    // If the semaphore is not available, wait 200 ticks of the Scheduler to see if it becomes free.
    if ( xSemaphoreTake( xSerialSemaphore, ( TickType_t ) 200 ) == pdTRUE )
    {

      // Calculate total number 
      int task6Counter;
      task6Runs = task6Runs+1;   //Serial print

      
      //////// Calculate total number of violations ////////
      int currentFrame, lastFrame;
      if(currentFrame == NULL){
        currentFrame = xCurrentExecutionTime; //initialize first frame at the time the task was first run
      }
      currentFrame = currentFrame + xFrequency; //increment current frame by exactly 100ms
      
      if (xCurrentExecutionTime > currentFrame || xCurrentExecutionTime < lastFrame) {    // Check if the task to test has run every 100ms
        task6Violations = task6Violations + 1;     // Task has not run every 100ms
      } 
      
      lastFrame = currentFrame; //Save current frame as the previous frame for the next run
 
      //Perform Task 6
      int toggleButton;
      queueLED = xQueueCreate(10, sizeof(int));  // Create the event queue with a size of 10
      if(digitalRead(TASK_6_BUTTON)==HIGH){   //Button 2 = 1 run signal B followed by 
          toggleButton=1;
          xQueueSend(queueLED, &toggleButton, 0);  // Send the event to the queue                                     
      }
      if(digitalRead(TASK_6_BUTTON)==LOW){   //Button 2 = 1 run signal B followed by 
          toggleButton=0;
          xQueueSend(queueLED, &toggleButton, 0);  // Send the event to the queue                                      
      }

      xSemaphoreGive( xSerialSemaphore ); // Now free or "Give" the Serial Port for others.
      //uint32_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
      //printf("Task 6 stack high water mark: %u bytes\n", uxHighWaterMark);
      
    }

    // Wait until the end of the task period
    vTaskDelayUntil( &xCurrentExecutionTime, xFrequency );
  }
}

void Task7(void *pvParameters) {                    //Takes 122us
  
    
    TickType_t xCurrentExecutionTime;
    const TickType_t xFrequency = pdMS_TO_TICKS( 100 ); // Task period (in milliseconds)

    // Initialize xLastWakeTime to the current tick count
    xCurrentExecutionTime = xTaskGetTickCount();
  
  for (;;)
  {

    // See if we can obtain or "Take" the Serial Semaphore.
    // If the semaphore is not available, wait 200 ticks to see if it becomes free.
    if ( xSemaphoreTake( xSerialSemaphore, ( TickType_t ) 200 ) == pdTRUE )
    {

      //////// Calculate total number iterations ////////
      int task7Counter;     
      task7Runs = task7Runs+1;   //Serial print

      //////// Calculate total number of violations ////////
      int currentFrame, lastFrame;
      if(currentFrame == NULL){
        currentFrame = xCurrentExecutionTime; //initialize first frame at the time the task was first run
      }
      currentFrame = currentFrame + xFrequency; //increment current frame by exactly 100ms
      /*
      Serial.print(xFrequency);
      Serial.print('\n');
      Serial.print(currentFrame);
      Serial.print('\n');
      */
      if (xCurrentExecutionTime > currentFrame || xCurrentExecutionTime < lastFrame) {    // Check if the task to test has run every 100ms
        task7Violations = task7Violations + 1;     // Task has not run every 100ms
      } 

      lastFrame = currentFrame; //Save current frame as the previous frame for the next run
        
 
      //////// Perform Task 7 ////////
      int toggleLED;
      xQueueReceive(queueLED, &toggleLED, 1);  // Wait for an event to be received from the queue
      if(toggleLED==1){   //Button 2 = 1 run signal B followed by 
          digitalWrite(TASK_7_LED, HIGH);                                     
      }
      if(toggleLED==0){   //Button 2 = 1 run signal B followed by 
          digitalWrite(TASK_7_LED, LOW);                                     
      }

      xSemaphoreGive( xSerialSemaphore ); // Now free or "Give" the Serial Port for others.
      //uint32_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
      //printf("Task 7 stack high water mark: %u bytes\n", uxHighWaterMark);
      
    }

    // Wait until the end of the task period
    vTaskDelayUntil( &xCurrentExecutionTime, xFrequency );
  }
}

void Task8(void *pvParameters) {
  
    TickType_t xCurrentExecutionTime;
    const TickType_t xFrequency = pdMS_TO_TICKS( 10000 ); // Task period (in milliseconds)

    // Initialize xLastWakeTime to the current tick count
    xCurrentExecutionTime = xTaskGetTickCount();
  
  for (;;)
  {

    // See if we can obtain or "Take" the Serial Semaphore.
    // If the semaphore is not available, wait 200 ticks of the Scheduler to see if it becomes free.
    if ( xSemaphoreTake( xSerialSemaphore, ( TickType_t ) 200 ) == pdTRUE )
    {

      int task1RunsNew, task1RunsOld;
      int task2RunsNew, task2RunsOld;
      int task3RunsNew, task3RunsOld;
      int task4RunsNew, task4RunsOld;
      int task5RunsNew, task5RunsOld;
      int task6RunsNew, task6RunsOld;
      int task7RunsNew, task7RunsOld;
      
      task1RunsNew = task1Runs - task1RunsOld;
      task2RunsNew = task2Runs - task2RunsOld;
      task3RunsNew = task3Runs - task3RunsOld;
      task4RunsNew = task4Runs - task4RunsOld;
      task5RunsNew = task5Runs - task5RunsOld;
      task6RunsNew = task6Runs - task6RunsOld;
      task7RunsNew = task7Runs - task7RunsOld;
      
      Serial.printf("PERFORMANCE SUMMARY:\n");   //Serial print     
      Serial.printf("Task 1 Iterations:%d/%d\n",task1Violations, task1RunsNew);   //Serial print
      Serial.printf("Task 2 Iterations:%d/%d\n",task2Violations, task2RunsNew);   //Serial print
      Serial.printf("Task 3 Iterations:%d/%d\n",task3Violations, task3RunsNew);   //Serial print
      Serial.printf("Task 4 Iterations:%d/%d\n",task4Violations, task4RunsNew);   //Serial print
      Serial.printf("Task 5 Iterations:%d/%d\n",task5Violations, task5RunsNew);   //Serial print
      Serial.printf("Task 6 Iterations:%d/%d\n",task6Violations, task6RunsNew);   //Serial print
      Serial.printf("Task 7 Iterations:%d/%d\n",task7Violations, task7RunsNew);   //Serial print
      task1RunsOld = task1Runs;
      task2RunsOld = task2Runs;
      task3RunsOld = task3Runs;
      task4RunsOld = task4Runs;
      task5RunsOld = task5Runs;
      task6RunsOld = task6Runs;
      task7RunsOld = task7Runs;
      
      task1Violations = 0;
      task2Violations = 0;
      task3Violations = 0;
      task4Violations = 0;
      task5Violations = 0;
      task6Violations = 0;
      task7Violations = 0;

      xSemaphoreGive( xSerialSemaphore ); // Now free or "Give" the Serial Port for others.
      uint32_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
      printf("Task 8 stack high water mark: %u bytes\n", uxHighWaterMark);
      
    }

    // Wait until the end of the task period
    vTaskDelayUntil( &xCurrentExecutionTime, xFrequency );
  }
}
